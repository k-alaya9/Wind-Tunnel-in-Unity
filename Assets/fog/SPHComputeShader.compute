// #pragma kernel CSMain

// struct Particle
// {
//     float3 position;
//     float3 velocity;
//     float3 currentForce;
//     float density;
//     float pressure;
// };
// RWStructuredBuffer<Particle> particles;
// float deltaTime;
// float smoothingRadius;
// float stiffness;
// float restDensity;
// float viscosity;
// float3 gravity;
// float3 boxSize;
// float PI = 3.1415926535897932384626433832795028841971;

// float3 SpikyKernelGradient(float distance, float3 directionFromCenter)
// {
//     float x = 1.0f - distance / smoothingRadius;
//     return directionFromCenter * (-45.0f / ( PI * pow(smoothingRadius,4) ) * x * x);
// }

// [numthreads(100, 1, 1)]
// void CSMain (uint3 id : SV_DISPATCHTHREADID)
// {
//     uint i = id.x;

//     // Load particle data
//     Particle p = particles[i];

//     // Calculate density
//     float density = 0;
//     float stdKernal=0;
//     for (uint j = 0; j < particles.Length; j++)
//     {
//         if (i == j) continue;
//         float3 dir =p.position - particles[j].position;
//         float r = dot(dir,dir);
//         if (r < pow(smoothingRadius,2))
//         {
//             // density += pow( abs(smoothingRadius - r), 3);
//             float x = 1.0f - r / pow(smoothingRadius,2);
//             stdKernal=315.f / ( 64.f * PI * pow(smoothingRadius,3) ) * x * x * x;
//             density+=stdKernal;
//         }
//     }

//     p.density = density * 1 + 0.00001f;
    
//     // Calculate pressure
//     p.pressure = stiffness * (p.density - restDensity);
//     if(p.pressure <= 0) p.pressure=0;

//     // Calculate forces
//     float3 pressureForce = float3(0, 0, 0);
//     float3 viscosityForce = float3(0, 0, 0);
//     for (uint l = 0; l < particles.Length; l++)  // Renamed loop variable to 'l'
//     {
//         if (i == l) continue;
//         float3 dir =distance(particles[l].position , p.position); // Changed this line
//         float r = length(dir);
//         if (r < smoothingRadius * 2)
//         {
//             // Pressure force
//             // float pressure = particles[l].pressure;

//             float3 pressureGradientDirection = normalize(p.position - particles[l].position);
//             pressureForce += 1 * ( p.pressure / pow(p.density,2) + particles[l].pressure / ( particles[l].density * particles[l].density ) ) * SpikyKernelGradient(dir, pressureGradientDirection); 
//             // pressureForce += normalize(dir) * (p.pressure + pressure) / (2 * particles[l].density) * (-45.0f / (PI * pow(smoothingRadius, 6))) * pow(smoothingRadius - r, 2);

//             // Viscosity force
//             viscosityForce += viscosity * 1 * (particles[l].velocity - p.velocity) / particles[l].density * (90.0f / (PI * pow(smoothingRadius, 5))) * (1-(dir/smoothingRadius));
//         }
//     }

//     // Combine forces and update velocity
//     p.currentForce = gravity - pressureForce + viscosityForce;
//     // float3 force = pressureForce + viscosityForce + gravity;
//     // p.velocity += p.currentForce * deltaTime;
//     float3 vel = p.velocity + ((p.currentForce) *deltaTime);
//     // Update position
//     p.position += vel * deltaTime;

//         // Write back updated particle data


//             // Check if particle is outside bounds and clamp position if necessary
//         // if (p.position.x < 0 || p.position.x > boxSize.x)
//         //     p.position.x = 0;
//         // if (p.position.y < 0 || p.position.y > boxSize.y)
//         //     p.position.y = 0;
//         // if (p.position.z < 0 || p.position.z > boxSize.z)
//         //     p.position.z = 0;
        
//     float boundDamping=-0.3;
//     // Minimum Enforcements
//     float3 topRight = boxSize / 2;
//     float3 bottomLeft = -boxSize/2;
//     if (p.position.x - smoothingRadius < bottomLeft.x) {
//        vel.x *= boundDamping;
//         p.position.x = bottomLeft.x + smoothingRadius;
//     }

//     if (p.position.y - smoothingRadius < bottomLeft.y) {
//        vel.y *= boundDamping;
//         p.position.y = bottomLeft.y + smoothingRadius;
//     }

//     if (p.position.z - smoothingRadius < bottomLeft.z) {
//        vel.z *= boundDamping;
//         p.position.z = bottomLeft.z + smoothingRadius;
//     }

//     // Maximum Enforcements

//     if (p.position.x + smoothingRadius > topRight.x) {
//        vel.x *= boundDamping;
//         p.position.x = topRight.x - smoothingRadius;
//     }

//     if (p.position.y + smoothingRadius > topRight.y) {
//        vel.y *= boundDamping;
//         p.position.y = topRight.y - smoothingRadius;
//     }

//     if (p.position.z + smoothingRadius > topRight.z) {
//        vel.z *= boundDamping;
//         p.position.z = topRight.z - smoothingRadius;
//     }
//     particles[i] = p;


// }
// #pragma kernel CSMain

// struct Particle
// {
//     float3 position;
//     float3 velocity;
//     float3 currentForce;
//     float density;
//     float pressure;
// };

// RWStructuredBuffer<Particle> particles;
// float deltaTime;
// float smoothingRadius;
// float stiffness;
// float restDensity;
// float viscosity;
// float3 gravity;
// float3 boxSize;
// float PI = 3.1415926535897932384626433832795028841971;

// float Poly6Kernel(float r2, float h2)
// {
//     float coef = 315.0f / (64.0f * PI * pow(h2, 3));
//     return coef * pow(h2 - r2, 3);
// }

// float3 SpikyKernelGradient(float r, float3 rVec, float h)
// {
//     float coef = -45.0f / (PI * pow(h, 6));
//     return coef * pow(h - r, 2) * rVec / r;
// }

// float ViscosityKernelLaplacian(float r, float h)
// {
//     float coef = 45.0f / (PI * pow(h, 6));
//     return coef * (h - r);
// }

// [numthreads(100, 1, 1)]
// void CSMain(uint3 id : SV_DISPATCHTHREADID)
// {
//     uint i = id.x;
//     Particle p = particles[i];

//     // Step 1: Compute density
//     p.density = 0.0f;
//     for (uint j = 0; j < particles.Length; j++)
//     {
//         float3 rVec = p.position - particles[j].position;
//         float r2 = dot(rVec, rVec);
//         if (r2 < smoothingRadius * smoothingRadius)
//         {
//             p.density += Poly6Kernel(r2, smoothingRadius * smoothingRadius);
//         }
//     }

//     // Add self-contribution to density
//     p.density += Poly6Kernel(0.0f, smoothingRadius * smoothingRadius);
//     p.density = max(p.density, 0.00001f);

//     // Step 2: Compute pressure
//     p.pressure = stiffness * (p.density - restDensity);

//     // Step 3: Compute forces
//     p.currentForce = float3(0, 0, 0);
//     for (uint j = 0; j < particles.Length; j++)
//     {
//         if (i == j) continue;
//         float3 rVec = p.position - particles[j].position;
//         float r = length(rVec);
//         if (r < smoothingRadius)
//         {
//             // Pressure force
//             float3 pressureGradient = SpikyKernelGradient(r, rVec, smoothingRadius);
//             float pressureForceMagnitude = (p.pressure / (p.density * p.density) + particles[j].pressure / (particles[j].density * particles[j].density));
//             p.currentForce += -pressureGradient * pressureForceMagnitude;

//             // Viscosity force
//             float viscosityLaplacian = ViscosityKernelLaplacian(r, smoothingRadius);
//             p.currentForce += viscosity * viscosityLaplacian * (particles[j].velocity - p.velocity) / particles[j].density;
//         }
//     }

//     // Apply external forces (gravity)
//     p.currentForce += gravity;

//     // Step 4: Update velocity and position
//     p.velocity += p.currentForce * deltaTime;
//     p.position += p.velocity * deltaTime;

//     // Step 5: Handle boundary conditions
//     float3 topRight = boxSize / 2;
//     float3 bottomLeft = -boxSize / 2;

//     if (p.position.x < bottomLeft.x + smoothingRadius || p.position.x > topRight.x - smoothingRadius)
//     {
//         p.velocity.x *= -1;
//         p.position.x = clamp(p.position.x, bottomLeft.x + smoothingRadius, topRight.x - smoothingRadius);
//     }
//     if (p.position.y < bottomLeft.y + smoothingRadius || p.position.y > topRight.y - smoothingRadius)
//     {
//         p.velocity.y *= -1;
//         p.position.y = clamp(p.position.y, bottomLeft.y + smoothingRadius, topRight.y - smoothingRadius);
//     }
//     if (p.position.z < bottomLeft.z + smoothingRadius || p.position.z > topRight.z - smoothingRadius)
//     {
//         p.velocity.z *= -1;
//         p.position.z = clamp(p.position.z, bottomLeft.z + smoothingRadius, topRight.z - smoothingRadius);
//     }

//     // Write back to buffer
//     particles[i] = p;
// }


#pragma kernel ComputeDensityPressure
#pragma kernel ComputeForces
#pragma kernel Integrate

struct Particle
{
    float pressure;
    float density;
    float3 currentForce;
    float3 velocity;
    float3 position;
};

RWStructuredBuffer<Particle> _particles;

float particleMass = 2.0;
float viscosity = 200;
float gasConstant = 2000;
float restDensity = 300;
float boundDamping = -0.5;
float radius = 2;
float radius3 = 8;
float radius2 = 4;
float radius4 = 16;
float radius5 = 32;
float pi = 3.1415926535897932384626433832795028841971;

int particleLength;

// float densityWeightConstant = 0.00497359197162172924277761760539;
// float spikyGradient = -0.09947183943243458485555235210782;
// float viscLaplacian = 0.39788735772973833942220940843129;

float timestep = 1;

float3 boxSize;

float StdKernel(float distanceSquared)
{
    float x = 1.0f - distanceSquared / radius2;
    return 315.f / ( 64.f * pi * radius3 ) * x * x * x;
}


[numthreads(100,1,1)]
void ComputeDensityPressure (uint3 id: SV_DISPATCHTHREADID)
{
    
   float3 origin = _particles[id.x].position;
   float density = 0;
   
   for (int i = 0; i < particleLength; i++) {
    
        if (origin.x == _particles[i].position.x && origin.y == _particles[i].position.y && origin.z == _particles[i].position.z) {
            continue;
        }

        float3 diff = origin - _particles[i].position;
        float distanceSquared = dot(diff, diff);
        
        if (radius2*0.004 > distanceSquared*0.004) {
            float x = (radius2*0.004) - (distanceSquared*0.004);
            density += StdKernel(distanceSquared*0.004);
        } 
   }
    
   _particles[id.x].density = density * particleMass + 0.000001f;
   _particles[id.x].pressure = gasConstant * (_particles[id.x].density - restDensity);

   if (_particles[id.x].pressure <= 0) _particles[id.x].pressure = 0;
}


// Doyub Kim page 130
float SpikyKernelFirstDerivative(float distance)
{
    float x = 1.0f - distance / radius;
    return -45.0f / ( pi * radius4 ) * x * x;
}

// Doyub Kim page 130
float SpikyKernelSecondDerivative(float distance)
{
    // Btw, it derives 'distance' not 'radius' (h)
    float x = 1.0f - distance / radius;
    return 90.f / ( pi * radius5 ) * x;
}


float3 SpikyKernelGradient(float distance, float3 directionFromCenter)
{
    return SpikyKernelFirstDerivative(distance) * directionFromCenter;
}

float3 spherePos;
float sphereRadius;

[numthreads(100,1,1)]
void ComputeForces (uint3 id: SV_DISPATCHTHREADID)
{
    float3   origin = _particles[id.x].position;
    float density2 = _particles[id.x].density * _particles[id.x].density; 
    float3 pressure = float3(0,0,0);
    float3 visc = float3(0,0,0);
    float mass2 = particleMass * particleMass;

    for (int i = 0; i < particleLength; i++) {
        
        if (origin.x == _particles[i].position.x && origin.y == _particles[i].position.y && origin.z == _particles[i].position.z) {
            continue;
        }

        float dist = distance(_particles[i].position, origin);
        if (dist < radius*2) {
            float3 pressureGradientDirection = normalize(_particles[id.x].position - _particles[i].position);
            pressure += mass2 * ( _particles[id.x].pressure / density2 + _particles[i].pressure / ( _particles[i].density * _particles[i].density ) ) * SpikyKernelGradient(dist, pressureGradientDirection);   // Kim
            visc += viscosity * mass2 * ( _particles[i].velocity - _particles[id.x].velocity ) / _particles[i].density * SpikyKernelSecondDerivative(dist);
        }
    }

    _particles[id.x].currentForce = float3(0,(-9.81 * particleMass), 0) - pressure + visc;

    // Handle Collision

    float3 colDir = _particles[id.x].position-spherePos;
    if (length(colDir) < sphereRadius) {
        float mag = sphereRadius/length(colDir);
        _particles[id.x].currentForce += colDir*300*mag;
    }

    // + pressure + visc/_particles[id.x].density;
}

[numthreads(100,1,1)]
void Integrate (uint3 id: SV_DISPATCHTHREADID)
{
    // _particles[id.x].velocity += timestep * _particles[id.x].
    float3 topRight = boxSize / 2;
    float3 bottomLeft = -boxSize/2;

    float3 vel = _particles[id.x].velocity + ((_particles[id.x].currentForce/particleMass) *timestep);
    _particles[id.x].position += vel * timestep;

    

    // Minimum Enforcements

    if (_particles[id.x].position.x - radius < bottomLeft.x) {
       vel.x *= boundDamping;
        _particles[id.x].position.x = bottomLeft.x + radius;
    }

    if (_particles[id.x].position.y - radius < bottomLeft.y) {
       vel.y *= boundDamping;
        _particles[id.x].position.y = bottomLeft.y + radius;
    }

    if (_particles[id.x].position.z - radius < bottomLeft.z) {
       vel.z *= boundDamping;
        _particles[id.x].position.z = bottomLeft.z + radius;
    }

    // Maximum Enforcements

    if (_particles[id.x].position.x + radius > topRight.x) {
       vel.x *= boundDamping;
        _particles[id.x].position.x = topRight.x - radius;
    }

    if (_particles[id.x].position.y + radius > topRight.y) {
       vel.y *= boundDamping;
        _particles[id.x].position.y = topRight.y - radius;
    }

    if (_particles[id.x].position.z + radius > topRight.z) {
       vel.z *= boundDamping;
        _particles[id.x].position.z = topRight.z - radius;
    }

    
    _particles[id.x].velocity = vel;
}